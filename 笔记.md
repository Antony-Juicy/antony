# 1.普通函数和箭头函数的区别？

?      答：

?          1.箭头函数是匿名函数，不能作为构造函数，不能使用new
          2.箭头函数不绑定arguments，取而代之用rest参数...解决
          3.箭头函数通过 call()  或   apply() 方法调用一个函数时，只传入了一个参数，对 this并没有影响。箭头函数内的this指向上层对象，bind()、call()、apply()均无法改变指向
          4.箭头函数没有原型属性
          5.箭头函数不能当做Generator函数,不能使用yield关键字

?       （yield关键字很像return，所不同的是，它返回的是一个生成器。 ）

?          6.两种函数的this代表不一样：f1是箭头函数，this代表上层对象，若无自定义上层，则代表window。普通函数，this代表当前对象。

# 2.vue中组件的data为什么是一个函数?

?      答：为了保证组件的独立性 和 可 复用性，data 是一个函数，组件实例化的时候这个函数将会被调用，返回一个对象，计算机会给这个对象分配一个内存地址，你实例化几次，就分配几个内存地址，他们的地址都不一样，所以每个组件中的数据不会相互干扰，改变其中一个组件的状态，其它组件不变。

# 2.5.js如何实现继承？

?      答：方法一：借助原型链，这利用原型让一个引用类型继承另外一个引用类型的属性和方法。
          方法二：借用构造函数，在子类型构造函数的内部调用超类构造函数，通过使用call()和apply()方法可以在新创建的对象上执行构造函数。
          方法三：组合继承，将原型链和借用构造函数的技术组合在一块，从而发挥两者之长的一种继承模式。
          方法四：原型式继承，借助原型可以基于已有的对象创建新对象，同时还不必须因此创建自定义的类型。
          方法五：寄生组合式继承，通过借用函数来继承属性，通过原型链的混成形式来继承方法
          方法六：创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真正是它做了所有工作一样返回对象。

# 3.什么是闭包？ 

?      答：我的理解是: 闭包就是能够读取其他函数内部变量的函数。在本质上，闭包是将函数内部和函数外部连接起来的桥梁。缺点是会造成内存溢出，变量无法被销毁 

?         **闭包的作用** :

?                              1.访问其他函数内部变量 

?                              2.保护变量不被内存回收机制回收 

?                              3.避免全局变量被污染 方便调用上下文的局部变量 加强封装性 

?        **闭包的缺点:** 

?                             闭包长期占用内存，内存消耗很大，可能导致内存泄露 

?      **如何避免闭包引起的内存泄漏** :

?                             在退出函数之前，将不使用的局部变量全部删除。

# 4.路由是怎么实现的？

?      答：是用哈希值的改变来检测哈希值的改变组件

利用onhashChange()

# 5.css3-单位px与vw,rem的区别?

?      答：px：绝对单位，页面按精确像素展示。
          em：相对单位，基准点为父节点字体的大小，如果自身定义了font-size按自身来计算（浏览器默认字体是16px），整个页面内1em不是一个固定的值。
          rem：相对单位，可理解为”root em”, 相对根节点html的字体大小来计算，CSS3新加属性，chrome/firefox/IE9+支持。

# 6.apply，call与bind的区别？

?      答：1.共同点:
                1.都能改变this指向
                2.都是函数的原型方法
          2.不同点：
                1.call和apply都会调用函数，bind不会调用
                2.call和apply得到函数的返回值，bind得到一个新的函数
                3.bind改变this指向只认第一次
                4.apply只能传递一个参数，参数只能为数组，call和bind传递参数一致
                    例：    fn.apply(window,[1,2,3,4])
                                fn.call(window,1,2,3,4)
                                fn.bind(window,1,2,3,4)

# 7.vue里面hash，history有啥区别？

?      答：最直观的区别就是在url中 hash 带了一个很丑的 # 而history是没有#的，
          1.hash 虽然出现在 URL 中，但不会被包括在 HTTP 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面。
          2.history利用了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法。（需要特定浏览器支持
这两个方法应用于浏览器的历史记录栈，在当前已有的 back、forward、go 的基础之上，它们提供了对历史记录进行修改的功能。只是当它们执行修改时，虽然改变了当前的 URL，但浏览器不会立即向后端发送请求。一般需要后端配合设置，否则上线之后会出现刷新丢失页面的情况

前端需要将哈希模式改为history模式

# 8.jsonp的原理？

?     答：例如img标签的src和link标签的href会发送一个get请求去请求静态资源。那么我们通过这点可以发现这些标签的src和link属性，并没有受同源策略的限制。jsonp就是使用同源策略这一“漏洞”，实现的跨域请求。

> jsonp请求需要服务器支持

- 发送**全局函数名**给后端

- script标签请求接口返回js代码

  > js代码格式：全局函数的执行代码

# 9.浏览器前缀？

?    答：1. -webkit   谷歌
            2. -o        opera

    3. -moz      火狐
    4. -ms       ie

# 10.浏览器内核？

- a、 IE(IE浏览器) : trident 内核    -ms-

  b、 Firefox(火狐浏览器) ： gecko 内核     -moz-

  c、 Safari(苹果浏览器) ：webkit 内核      -webkit-

  d、 Opera(欧朋浏览器)：以前是 presto 内核， Opera 现已改用 Google  Chrome 的 Blink 内核     -o-

  e、 Chrome(谷歌浏览器)：Blink(基于 webkit ， Google 与 Opera Software 共同开发 )     -webkit

# 10.原型链继承的优缺点?

?    答：原型链实现继承的基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。
        1.缺点就是让结果所有的子类的实例都会共享父类的实例属性
        2.通过原型链继承的方式，原先存在父类型的实例中的所有属性和方法，现在也能存在于子类型的原型中了。

# 11.Vue中computed和watch的区别?

?    答：**计算属性computed**  

1. 支持缓存，只有依赖数据发生改变，才会重新进行计算
2. 不支持异步，，当computed内有异步操作时无效，无法监听数据的变化
3. 如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多,或者多对一，甚至一对一，一般用computed

?         4.computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值
        5.如果computed属性属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法。
    **侦听属性watch**
        1. 不支持缓存，数据变，直接会触发相应的操作；
        2.watch支持异步；
        3.监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；

4.可以监听路由；

                4. 当一个属性发生变化时，需要执行对应的操作
                5. 监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数， 

```
watch耗性能，computed会缓存，一般用computed，性能考虑） 
```

# 11.5method ，computed，watch的区别？

答：

- method 是对函数的调用，computed是对属性的调用。methods方法页面刚加载时调用一次，以后只有被调用的时候才会被调用。
- computed 具有缓存功能，在系统刚运行的时候调用一次。只有只有当计算结果发生变化才会被调用。computed 对于其中变量的依赖是多个的，它的函数中使用了多个 this.xxx ,只要其中一个发生了变化，都会触发这个函数。
- 而 watch 的依赖则是单个的，它每次只可以对一个变量进行监控。

# 11.9watch与computed的区别？

作用：两者都可以用来监听属性的变化。

computed：根据其他依赖的属性，来形成新的属性；

watch:用来监听data或props属性中数据的变化，从而触发相关操作；

 

区别：

##### computed：

1、是基于data中声明过或父组件传递的props中的数据计算得到的；

2、computed结果会被缓存，只有当依赖的数据发生变化才会重新计算；

3、不支持异步，当computed内有异步操作时无效，无法监听数据的变化；

4、computed中的属性有get和set方法，但是默认走get方法。

##### watch：

1、watch监听的数据必须是data中声明过或父组件传递的props中的数据；

2、watch不会被缓存，当监听的数据变化时，直接出发响应的操作。

3、支持异步

4、watch方法中有两个属性：immediate（组件加载立即触发方法），deep（深度监听）

5、使用场景：需要执行异步操作，或者开销较大的操作。

# 12.谈谈对原型与原型链的理解?

?    答：

原型链（对象查找属性的一个机制）实例到Object.prototype间的一个链条，

就近原则查找---》在自己的作用域找，有就使用，没有就继续往上层查找，直到找到全局为止，还找不到就会报错

1.在本身的对象上查找一个属性，如果有就直接使用，没有就去所属的构造函数上的原型对象查找

2.在构造函数的原型上，找到就使用，找不到就继续去构造函数的原型对象的原型对象上查找

3.直到找到object的原型对象上，如果找到就使用，找不到就报错了

属性访问规则（在原型链中逐层往上查找，找不到返回underfind）

属性访问规则（在原型链中逐层往上查找，找不到返回报错）

三者的关系（构造函数，原型链，原型对象）

1. 每个构造函数都有一个原型对象（prototype）
2. 原型对象都包含一个指针指向构造函数（constructor）
3. 所以的实例都通过_ _proto_ _ _指向同一个原型对象（包含一个指向原型对象的内部指针（[[prototype]]）

构造函数new出来一个对象，而每个对象都有一个constructor属性，该属性指向创建该实例的构造函数，构造函数的prototype属性是这个new出来的实例化对象的原型，实例对象通过____proto___或者object.getPrototype的方法获取原型。
扩展：
套用一句很粗暴的话，所谓原型链就是找妈的一种行为方式，就可以理解为人是人他妈生的，妖是妖他妈生的。原型链的核心其实就只有一个：属性共享和独立的控制，当你的对象实例需要独立的属性，所有做法的本质都是在对象实例里面创建属性。若不考虑太多，你大可以在Person里面直接定义你所需要独立的属性来覆盖掉原型的属性。总之，使用原型继承的时候，要对于原型中的属性要特别注意，因为他们都是牵一发而动全身的存在。现在最常用的方法是组合模式。

# 13.vue中怎么实现反向代理？

?    答：设置config/index.js中的proxy，不过我之前工作的时候习惯在配置.env.development，里面提前配置# 配置开发常量和#  接口服务地址，配置好了之后再用这个配置的文件接口名替换一下就行了



# 13.5对vue的理解？

答：Vue是一套构建用户界面的渐进式框架,也可以理解为是一个视图模板引擎,强调的是状态到界面的映射。 

是一套构建用户界面的渐进式框架。 

Vue.js 的目标是通过尽可能简单的 API 实现**响应的数据绑定**和**组合的视图组件**。 

# 14.cookie和localstorage以及sessionStorage的区别？

?    答：1.cookie可以在前后端访问，localstorage只能前端浏览器访问
            2.cookie可以在前后端操作，localstorage只能前端操作
             3.cookie的过期时间，不设置的话就是浏览器会话时间，localstorage永远不会过期，除非手动删除
        4.cookie只能储存4kb,localstorage能储存无限

5.sessionStorage：仅在当前会话下有效，关闭页面或浏览器后被清除。仅在客户端（即浏览器）中保存，不参与和服务器的通信

# 15.怎样减少请求次数？

?    答：将数据存在本地，点击时和本地数据判断，缺点是不够有时效性，把库存量存在本地，点击加号的时候和本地比较，只要不超过库存量就发送请求

# 16.!!!!vuex里面有哪些属性!!!!？

?    答：**state**(vuex的基本数据，用来存储变量 )

，**mutations**--commit触发(更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。也就是说，mutations才是改变状态的执行者。 注意：mutations只能是同步地更改状态.)

**,actions --dispatch触发**(action 类似于 mutation, 不同在于：action 提交的是 mutation,而不是直接变更状态action 可以包含任意异步操作 vue 中 ajax 请求代码应该写在组件的 methods 中还是 vuex 的 action 中。 )

,**modules**(面对复杂的应用程序，当管理的状态比较多时；我们需要将vuex的store对象分割成模块(modules)。 )

**gettets**(getter 可以对 state 进行计算操作，它就是 store 的计算属性虽然在组件内也可以做计算属性，但是 getters 可以在多给件之间复用如果一个状态只在一个组件内使用，是可以不用 getters	 )

# 17.模块化开发的区别？

?    答：1.commonjs  -->同步
        2.amd&cmd  -->异步
        3.EsModule  -->静态引入，不能使用变量，其他模块可以

# 18.css可继承的属性？

?    答：字体系列属性，文本系列属性，元素可见性：visibility，表格布局属性，列表属性，页面样式属性,声音样式属性

# 19.hash路由的原理？

?    答：利用了window.onhashchange这个事件

# 20.webpack与gulp的区别？

?    答：gulp是基于任务的构建工具，webpack是基于配置的构建工具

# 21.webpack的工作原理？

?    答：把项目当做一个整体，通过入口文件（如：main.js）分析整个项目结构，找到所有依赖模块，并利用配置好的加载器，插件处理这些模块，最后打包为一个或多个浏览器可识别的文件

# 22.vue组件局部样式实现原理？

?    答：有了scoped,当前组件样式就都会被编译成带有**属性选择**器的名称。
        详细点说添加了scoped属性的组件会给组件内所有的html标签添加`data-v-[hash]`自定义属性，并把样式编译成属性选择器，达到只有当前组件才能匹配的样式 

# 23.async/await执行原理?

?    答：函数执行时，一旦遇到await就会返回。等到触发的异步操作完成（并且调用栈清空），再接着执行函数体内后面的语句。

# 24.vue和Reacth中的key的作用？

?    答：使用key的场景：**同级别同类型的节点**
        虚拟DOM--》diff算法：**对比前后状态（对象)，找出差异项，只更新差异部分**
        **key的作用就是用于识别虚拟节点，让diff算法更加高效**

# 25.影响页面性能的因素有哪些？

?    答：1.网络速度因素
        2.节点的数量
        3.节点的频繁操作
        4.事件数量



# 26.双向绑定的原理？Vue 实现数据双向绑定的原理?

?    答：一个单项的绑定再加上一个事件

Vue 是使用数据劫持, 结合发布者订阅者模式实现双向数据绑定的，通过**Object.defineProperty()**来实现数据劫持的。控制一个对象属性的一些特有操作，比如读写权、是否可以枚举，这里我们主要先来研究下它对应的两个描述属性get和set  

执行过程分析:
读取 title 或者 msg 的时候 get 方法会自动触发; 重新给 title 或 msg
赋值的时候,set 方法会被自动触发(可以在此处通知界面层更新)

# **27**.如何判定一个元素是否处于事件冒泡阶段？

?    答：利用e.currentTarget和e.target判断是否为同一元素，如果是同一元素就是在冒泡，e.currentTarget指的是被绑定了事件的元素，也就是事件源，e.target则是点击到的事件源下面的某个元素,也就是触发事件元素

# 28.for/for..in/for..of的区别？

?    答：这三个都能进行遍历，但我们一般使用**for来遍历数组**，用**for..in遍历对象**，**for..of用来遍历一些具有迭代特性的一些数据**具有   （symbol.iterator）的数据，就证明是可迭代的

# 29.getElementsByTagName与querySelectorALL区别？

?    答：querySelectorALL获取的是返回值**NodeList集合**，静态，是**不会自动更新**的，getElementsByTagName获取的是返回值**HTMLCollection集合**，是动态，**会自动更新**的**

![p](C:\Users\Administrator\Desktop\p.jpg)

# 30.jquery中attr()与prop()方法的区别？

?    答：attr()对应原生js中的**getAttribute()/setAttribute()**,用于设置html属性
        prop()对应原生**js的点语法，用来设置节点属性**



# 30.5props和state的区别是什么?

答：

props:

- props:函数组件的props就是函数的入参组件
- 类组件：this.props包含被该组件调用或者定义的props

state:

- 组件中的state包含了随时可能发生变化的数据。
- state是由用户定义，是一个普通的JavaScript对象

区别：

- props是传递给组件的（类似于函数的形参），而state是在组件内部被组件自己管理的（类似于在一个函数内声明的变量）
- props是不可以被修改的，所有的react组件都必须像纯函数一样保护他们的props不被修改
-  state是在组件中创建，一般是在constructor中初始化state
- state是多变的，可被修改的。每次setState都是异步更新的

# 30.9.如何解决跨域问题

答：

1、JSONP （JSONP只支持GET请求，不支持POST请求 ）

2.反向代理（写一个接口 ，由这个接口在后端去调用 ，并拿到返回值，然后再返回给index.html，这就是一个代理的模式。相当于绕过了浏览器端，自然就不存在跨域问题。 ）

3.CORS方法 （设置响应头，在header中添加

header('Access-Control-Allow-Origin:*');//允许所有来源访问

header('Access-Control-Allow-Method:POST,GET');//允许访问的方式）

# 31.jquery中链式调用的原理

?    答：在对象上的方法最后 加上**return this**
              把对象再**返回**回来，对象就继续调用方法了，所以就可以链式操作了。



# 31.5有没有使用过jq,知道jq的原理？

jq最核心的是 $ ，是一个函数。
函数中返回一个自定义的jq对象，它是一个类。
在这个类的原型下面有许多jq自定义的方法，如on,css。。。
每次调用 $ 都会返回一个新的jq对象，

同时在 $ 函数中，根据传入参数的类型，如（#div1, .div2, span等）,函数或者字符串，
把选中的元素存在数组中，遍历这个数组，去除每个元素进行dom操作。

jQuery可以链式操作，是因为，在每一个方法中，都会在最后 return this
返回了当前 $函数中的jq对象，所以就能继续链式操作了。

# 32.网络储存有哪些？

?    答：**localStorage,SessionStorage**(临时本地，可实现与cookie一样的功能), **IndexedDB,WebSQL,Cookie**

# 33.mvvm的理解？

?    答：MVVM分为**Model、View、ViewModel**三者

原理：**监听渲染的过程**

Model：**代表数据模型，数据和业务逻辑都在Model层中定义；**

  View：**代表UI视图，负责数据的展示；**

?       

简单点来说：**ViewModel就是View与Model的连接器，View与Model通过ViewModel实现双向绑定。**

# 33.5 vue生命周期有哪些？

答：beforeCreate （实例创建前）

created （实例创建后）

beforeMount (数据挂载前)

mounted （数据挂载后）

beforeUpdate （模板更新前）

update(模板更新后)

beforeDestroy(实例销毁前)

destroyed(实例销毁后)



# 33.8 react生命周期有哪些？

答：

constructor（初始化）

UNSAFE ComponentWillMount（组件渲染前   不推荐）

componentDidMount(组件渲染后立马执行)（发送AJAX 定时器等请求）

UNSAFE componentWillUpdate(组件更新前   不推荐)

componentDidUpdate(组件更新后立刻调用)

componentWillUnmount(组件从dom移除前调用)（此处适合清除定时器，终止aJax请求）

compoentWillReceiveProps(nextprops    不推荐)

shoundComponentUpdate(nextprops,nextState)  --->用于性能优化，props改变时调用，必须返回true或false来决定是否重新渲染组件



# 34.父子组件生命周期函数函数的执行顺序是怎么执行的？

答：**React**

1. 父组件constructor-----初始化

2. 父组件componentWillMount-----渲染前

3. 父组件的render-----渲染中

4. 子组件constructor-----初始化

5. 子组件componentWillMount-----渲染前

6. 子组件render-----渲染中

7. 子组件的componentDidMount-----渲染后

8. 父组件的componentDidMount-----渲染后

   

?    **  **Vue****

1. 父组件beforeCreate-----实例创建前
2. 父组件created-----实例创建后
3. 父组件beforeMount-----数据挂载前
4. 子组件beforeCreate-----实例创建前
5. 子组件created-----实例创建后
6. 子组件beforeMount-----数据挂载前
7. 子组件mounted-----数据挂载后
8. 父组件mounted-----数据挂载后

# 35.移动端适配方案？

答：一：缩放布局

?        1.rem布局

?        2.vw/vh/vmin/vmax

?      二：响应式布局

?      三：自适应布局

?      四：弹性盒

?      五：百分比.....

 PS：**一个完美的移动端适配方案不是单一的解决方案，而是所有解决方案的结合体**

# 36.谈谈你对高阶组件HOC的看法？（High Order Component）

 答：**不是一个组件，而是一个用来包装组件的函数(高阶函数/纯函数)，并且必须返回一个新的函数**

纯函数

1. 不修改传入的参数
2. 固定输入有固定输出

定义高阶组件（1.把组件作为参数传入   2.返回一个新的组件）

- 定义方式一： 属性代理
- 定义方式二： 反向继承 （一般都用于类组件）



# 37.深拷贝和浅拷贝的区别？

答：**深拷贝和浅拷贝最根本的区别在于是否真正获取一个对象的复制实体，而不是引用。**

假设B复制了A，修改A的时候，看B是否发生变化：

如果B跟着**也变了**，说明是**浅拷贝**，拿人手短！（修改堆内存中的同一个值）

如果B**没有改变**，说明是深拷贝，自食其力！（修改堆内存中的不同的值）

所以：**浅拷贝（shallowCopy）只是增加了一个指针指向已存在的内存地址，**

以及：**深拷贝（deepCopy）是增加了一个指针并且申请了一个新的内存，使这个增加的指针指向这个新的内存** 

# 38.5那如何对一个对象进行深拷贝呢？

答：**方法一：分别对数组、对象、基本数据类型值进行判断、考虑，使用递归的方式复制值**

**方法二：利用JSON.parse()、JSON.stringify()这两个方法实现深拷贝**



# 38.8那什么是递归呢？

答：递归，就是在运行的过程中调用自己， **斐波纳契数列是典型的递归案例** 

**构成递归所必须的条件？**

1.子问题须与原始问题为同样的事，且更为简单 

2.不能无限制地调用本身，须有个出口，化简为非递归状况处理 

# 38.谈谈 async/await 的使用方式和场景

答：async 是用来修饰函数的声明, 使用async 修饰的函数会变成一个异步
函数. 

await 用来修饰函数的调用, 被 await 修饰的函数必须返回一个
promise 异步对象, 使用 await 修饰后, 就会**将 promise 异步对象转换**
**成一个同步操作，**

一般配合**try**和**catch**使用



# 39.什么是虚拟DOM，以及他的优点

答：虚拟 DOM 到底是什么，说简单点，就是一个普通的 JavaScript 对象，包含了?`tag`、`props`、`children`?三个属性。 

虚拟 DOM 提升性能的点在于 DOM 发生变化的时候，通过 diff 算法比对 JavaScript 原生对象，计算出需要变更的 DOM，然后**只对变化的 DOM 进行操作**，而**不是更新整个视图**。 	



# 40.fetch和JQuery.ajax的不同?

答：1.fetch当接收到一个代表错误的HTTP状态码时，从fetch()**返回的的Promise不会被标记为reject**

?       2.fetch()可以接受跨域cookies

?      3.fetch()不会发送cookies



# 41.JS中的let和var的区别?

答：1.ES6可以用let定义块级作用域变量

?        2.`let`非常适合用于`for`循环内部的块级作用域。JS中的for循环体比较特殊，每次执行都是一个全新的独立的块作用域，用let声明的变量传入到 for循环体的作用域后，不会发生改变 

?        3.let没有变量提升与暂时性死区

?        4.let变量不能重复声明



# 41.5 ES6新特性？

答：

- let,const
- 字符串模板
- 解构
- 箭头函数
- ...运算符
- 对象简写
- **Promise**
- **class**
- **ESModule**
- **Proxy**
- Set/Map
- Generator（生成器）
- Iterator( 迭代器：  一个数据结构只要具有**Symbol.iterator**属性，就可以认为是“可遍历的”（iterable） 
- Symbol（本质上是一种唯一标识符，可用作对象的唯一属性名 ）



# 42.节流防抖的理解？

答：防抖和节流是针对响应跟不上触发频率这类问题的两种解决方案

?        有些事件我们是无法控制触发频率的。 如鼠标移动事件onmousemove, 滚动滚动条事件onscroll，窗口大小改变事件onresize，瞬间的操作都会导致这些事件会被高频触发。 

**防抖：抖动。策略是当事件被触发时，设定一个周期延迟执行动作，若期间又被触发，则重新设定周期，直到周期结束，执行动作。 这是debounce的基本思想，在后期又扩展了前缘debounce，即执行动作在前，然后设定周期，周期内有事件被触发，不执行动作，且周期重新设定**

**节流的策略是，固定周期内，只执行一次动作，若有新事件触发，不执行。周期结束后，又有事件触发，开始新的周期。 节流策略也分前缘和延迟两种。与debounce类似，延迟是指 周期结束后执行动作，前缘是指执行动作后再开始周期。** 



# 42.5express 中间件的理解？

答：express 中间件函数，帮助拆解主程序的业务逻辑，并且每一个的中间件函数处理的结果都会传递给下一个中间件函数。想象一下工厂上流水线工人，在清洗一个箱子的一个场景。 第一个人清洗侧面，第二个人清洗底面，第三个人清洗顶面，。。。，这条流水线结束后，箱子也就清洗干净了。 各做各的，不相互影响，又彼此协作。 

# 43.如何实现一个类似微信在同类型设备登陆后自动下线的状态效果？

答：利用websorket

或者轮询



# 44.原生js中一个事件触发的过程和阶段？

答：分为三个阶段，别分是

**1.捕获阶段**

**2.触发阶段**

**3.冒泡阶段**

# 45.先来看看当用户输入 URL，到浏览器呈现给用户页面，经历了哪些过程

答：

1. 用户输入 URL 地址。 
2. 对 URL 地址进行 DNS 域名解析。 
3. 建立 TCP 连接（三次握手）。 
4. 浏览器发起 HTTP 请求报文。 
5. 服务器返回 HTTP 响应报文。 
6. 关闭 TCP 连接（四次挥手）。 
7. 浏览器解析文档资源并渲染页面。（回流与重绘）

# 46.**游览器的重绘与回流** ？

答：1.当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为重绘。  

2.当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流(reflow)。每个页面至少需要一次回流，就是在页面第一次加载的时候，这时候是一定会发生回流的，因为要构建render tree。在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程成为重绘。 



# 47.原生ajax请求的五个步骤?

答：     第一步，创建XMLHttpRequest对象（var xmlHttp = new XMLHttpRequest()）

第二步，注册回调函数（xmlHttp.onreadystatechange =callback1;）

第三步，配置请求信息

第四步，发送请求,post请求下，要传递的参数放这

第五步，创建回调函数





# 48.vue路由模式改为history需要做哪些操作？

答：第一步：在实例化路由时配置mode属性：`mode:'history'`

?       第二步：服务器配置（除静态资源外的任何访问地址都响应index.html的请求）

# 48.在vue的双花括号{{}}为什么会闪动一下？原理是什么，解决方案是什么？

答：使用v-clock解决，使用属性选择器[v-clock]:{display:none}



# 49.Redux设计和使用的三项基本原则?

答：1.store是必须是唯一的

?       2.只有store能改变自己的内容 

?       3.Reducer必须是一个纯函数 



# 50.优雅降级和渐进增强 ？

答：**优雅降级：**优雅降级指的是一开始针对一个高版本的浏览器构建页面，先完善所有的功能。然后针对各个不同的浏览器进行测试，修复，保证低级浏览器也有基本功能 就好，低级浏览器被认为“简陋却无妨 (poor, but passable)” 可以做一些小的调整来适应某个特定的浏览器。 

**渐进增强 ：**渐进增强认为应该专注于内容本身。一开始针对低版本的浏览器构建页面，满足最基本的功能，再针对高级浏 览器进行效果，交互，追加各种功能以达到更好用户体验,换句话说，就是以最低要求，实现最基础功能为基本，向上兼容 



# 51.JSX的原理？

答：1.把jsx语法转换成一个名为?`React.createElement()`?的方法调用。 

2.基于createElement把传递的参数处理为jsx对象  

3.*基于render把jsx对象按照动态创建dom元素的方式插入到指定的容器中即可。* 



# 51.2.JSX的使用规范？

答:

1.Javascript与JSX代码不兼容，所以凡是使用JSX的script标签都要加上type="text/babel"

2.在JSX中  class==》className,  for==》htmlfor

3.属性使用驼峰命名

4.必须要有结束标签

5.style属性的值接收一个对象，css的属性必须为驼峰写法

6.花括号{}内为JS表达式，不能出现let var const等关键字



# 52.vue传递参数怎么限定传输的数据类型？

答：在props里面有一个type属性

 props: {  userName: {    type: Number,    default: 1  }}

通过type来限定想要传输的数据类型



# 53.什么是预解析？

答：JS代码在执行之前，会对代码进行预解析，寻找作用域中的var 和function ，然后对其进行事先声明，在从上到下执行代码。这就是一个预解析的过程。

 

# 54.常用的git常用指令？

答：1.git add. （ 添加至暂存区 ）

2.git commit （提交 ）

3.git push （ 推送至远程版本库 ）

4.git branch （分支管理 ）

5.git clone （克隆版本库 ）

6.git merge （分支合并 ）

7.git archive （文件归档打包 ）  等等......



# 55.验证码实现过程？

答：后端生成验证码，并存入session，并返回前端（图片）

后端验证：把前端输入的验证码发送到后端并与存在session中的验证码进行校验

难点：

1：如何识别两个请求为同一个用户（http请求为无状态请求）：利用session

?             第一次请求：获取验证码

?             第二次请求：发送验证码



# 56.vue中怎么监听所有属性的变化？ 和一个属性的变化？

答：所有属性变化

```
watch:{
    obj:{
        handler(newVal,oldVal){

        },
        deep:true
    }

}
```

?        一个属性变化

```
watch:{
    'obj.a':{
        handler(newVal,oldVal){

        }
    },
    '$route.path'(newVal,oldVal){
        //监听路由的变化
    }

}
```

# **57. 谈谈你对虚拟DOM的理解，以及好处？** 

答：虚拟DOM：虚拟DOM其实就是真实的js对象虚拟DOM提高了react的性能，每次数据更新后都会重新计算上虚拟DOM，并和上一次的虚拟DOM进行对比，对方法变化的部分进行批量更新。react中也提供了shouldComponentUpdate生命周期的回调，来减少数据变化后不必要的虚拟DOM对比过程。保证性能 



# 58.**谈谈你对react生命周期中shouldComponentUpdate的理解** ？

答：shouldComponentUpdate是react性能优化非常重要的一环。组件接受新的state或者props时调用，我们可以设置在此对比前后两个props和state是否相同，如果相同则返回false阻止更新，因为相同的属性状态一定会生成相同的dom树，这样就不需要创造新的dom树和旧的dom树进行diff算法对比，节省大量性能，尤其是在dom结构复杂的时候 



# 59.?**this.setState之后react做了哪些操作** ？

答：shouldComponentUpdate

 componentWillUpdate

 render

 componentDidUpdate 



# 60.?**当组件的key值发生改变后会执行哪些生命周期函数？** 

答：componentWillUnmount

 constructor

 componentWillMount 

render

componentDidMount 



# 60.4 git与github？

答：

- git是一个软件，是一个版本管理工具
- github是一个代码托管网站

# 61.?**在react中是否封装过组件？封装组件需要注意的地方？** 

答;常用封装组件用到的东西

1、propTypes 限制外部数据的类型

2、defaultProps 设置默认的外部数据

3、父传子 子传父 context 等传值方式

4、高阶组件封装组件的时候一定要注意组件的复用性，灵活性 



# 62.vue如何监听数据变化？

答:1.属性必须响应属性，如何把属性变成响应式属性？

1.初始化定义

2.Vue.set(target,proName,value)/this.$set()



# 63.tcp三次握手与四次挥手？

答：![1308525-20190113115419142-478609043](C:\Users\Administrator\Desktop\1308525-20190113115419142-478609043.png)



# 64.微任务和宏任务？

![1308525-20190113115454762-194039939](C:\Users\Administrator\Desktop\1308525-20190113115454762-194039939.png)

# 65.jsx的使用规范？

答：1.凡是使用jsx的script标签都需要加上 type="test/babel"

2.jsx中 class=className， for=htmlFor

3.属性使用驼峰命名  例：autofocus=autoFocus

4.必须要有结束标签

5.style属性的值接收一个对象，css的属性必须为驼峰写法

6.{}内为JS表达式，不能出现var let const 等关键字

7.注释需要添加花括号

# 66.如何保证前后端数据传输的安全性？

答：加密和解密

单向加密===》例：md5，sha1,sha256,sha512

缺点：(加密后的信息是固定：可以被暴力破解)

解决方案

- 次数限制
- 多次加密

双向加密：一般用于前后端数据通讯

- 对称加密

  > 加密与解密公用一把钥匙

  - 算法：AES/DES
  - 优点：速度快
  - 缺点：不安全

- 非对称加密

  > 有两把钥匙，分别为公钥和私钥
  >
  > - 公钥加密，私钥解密
  > - 私钥加密，公钥解密

  - 算法：RSA
  - 优点：安全
  - 缺点：速度慢

- 应用

  - https协议
  - git ssh协议

# 67.react组件优化?

答：

- shouldComponentUpdate
- PureComponent
- 优先使用函数组件

# 68.react 中State 与 Props 区别？

答：

- State是可变的，是一组用于反映组件UI变化的状态集合；
- 而Props对于使用它的组件来说，是只读的，要想修改Props，只能通过该组件的父组件修改。
  在组件状态上移的场景中，父组件正是通过子组件的Props, 传递给子组件其所需要的状态。

# 69.路由设置七步骤？

答：1.安装vue-router

2.引入vue-router

3.准备好子组件

4.配置好路由表

5.将router注入到vue里面

6.配置导航来接收。声明式和编程式都可以

7.设置路由接口



# 70.浏览器访问优化?

答：

**1、减少http请求，合理设置 HTTP缓存**

#### 2、使用浏览器缓存

#### 3、启用压缩

#### 4、 CSS Sprites（精灵图）

#### 5、Lazy Load Images（图片懒加载）

#### 6、CSS放在页面最上部，javascript放在页面最下面

#### 7、异步请求 Callback（就是将一些行为样式提取出来，慢慢的加载信息的内容）

#### 8、减少cookie传输

#### 9、Javascript代码优化

#### 10、CSS选择符优化



# 71.前端SEO优化？

答：

　1. 对网站的标题、关键字、描述精心设置，反映网站的定位，让搜索引擎明白网站是做什么的；

　　2. 网站内容优化：内容与关键字的对应，增加关键字的密度；

　　3. 在网站上合理设置Robot.txt文件；

　　4. 生成针对搜索引擎友好的网站地图；

        　　5. 增加外部链接，到各个网站上宣传；

# 72.前端seo优化具体操作？

**(1) 网站结构布局优化：尽量简单、开门见山，提倡扁平化结构。**

?         1.控制首页链接数量 

?         2.扁平化的目录层次，尽量让“蜘蛛”只要跳转3次，就能到达网站内的任何一个内页 

?         3.导航优化 （导航应该尽量采用文字方式，也可以搭配图片导航，但是图片代码一定要进行优化，`<img>`标签必须添加`“alt”`和`“title”`属性，告诉搜索引擎导航的定位，做到即使图片未能正常显示时，用户也能看到提示文字 ） 

?         4.控制页面的大小，减少http请求，提高网站的加载速度。 

**(2) 网页代码优化**

 1.`<title>`标题 ，每个页面的`<title>`标题中不要设置相同的内容。 

2.`<meta keywords>`标签：关键词，列举出几个页面的重要关键字即可，切记过分堆砌。 

3.`<a>`标签：页内链接，要加`“title”`?属性加以说明 

4.正文标题要用`<h1>`标签 



# 73.TCP跟UDP的区别?

1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之

2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付前不需要建立连接

3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的

4、UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）

5、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信

6、TCP首部开销20字节;UDP的首部开销小，只有8个字节

7、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道



# 74.把网址写到浏览器到你看到的网页整个流程？

答：

1.在浏览器地址栏中输入网址 

2.浏览器获取这个网址之后，会先去缓存中看看有没有要访问的资源，从浏览器缓存-系统缓存-路由缓存中查看，如果有就不再进行hhtp请求，直接从缓存中加载资源。否则进行步骤3 

3.浏览器拿到域名自动去向DNS(域名系统)服务器发起请求，查询用户输入的域名对应的ip地址  

4.浏览器拿到ip地址后，通过ip地址和端口号和服务器建立tcp连接。 

5.三次“握手”建立连接成功之后，浏览器开始向服务器发起http请求，并通过http协议将请求信息包装成请求报文（包含请求行、请求头、空行、请求体），然后通过socket发送到服务器 

6.当服务器接收到客户端浏览器发送过来的请求报文时候，按照 HTTP 协议将请求报文解析出来 

7.然后服务器拿着请求报文中的请求信息（例如请求路径url），做相应的业务逻辑处理操作 

8.当业务逻辑处理操作完成之后，服务器将发送给浏览器的数据按照http协议包装成响应报文（响应行、响应头、空行、响应体） 

9.然后服务器将响应报文发送给浏览器 

10.浏览器接收到响应报文后，按照HTTP协议将响应报文解析出来 

11.浏览器拿到响应报文中响应体的数据开始渲染html、css，执行javaScript 

12.如果在解析的过程（从上到下）中，发现有外链的标签（link、css、img） 

13.浏览器会自动对该标签指向的 路径地址 发起新的请求，同上。 



# 75.react跟vue的区别?

相同之处：

两者都是用于创建UI的JavaScript库；

两者都快速轻便；

都有基于组件的架构；

都是用虚拟DOM；

都可放入单个HTML文件中，或者成为更复杂webpack设置中的模块；

都有独立但常用的路由器和状态管理库；

差异：

**0、vue是一种渐进式框架，采用自底向上增量开发的设计**，

?      **react是采用函数式编程，推崇纯组件，数据不可变，单项数据流**

**1、监听数据变化的实现原理不同** 

**2、****数据流的不同（react-->单项数据流，vue是双向数据流）****

**3、HoC和mixins** 

**4、组件通信的区别** 

**5、模板渲染方式的不同** 

**6、渲染过程不同** 

**7、框架本质不同**



# 76.react有没有双向数据绑定，如果要实现双向绑定的话你有什么选择

答：react是没有像vue中实现数据绑定的v-module 这种方法的

但要想实现双向绑定可以使用event.target事件对象来更新react中的数据状态 

1.首先初始化状态 

this.state={"username":"" }

2.给输入框添加onChange事件 

<input type="text"  onChange={this.handleChange} /> 

<p>{this.state.username} </p> 
3.编写事件代码 

handleChange = (event) => { this.setState({ username: event.target.value }) } 

# 77.nodejs是单线程还是双线程

答：nodejs是单线程异步非阻塞模式 

Nodejs所谓的单线程，只是主线程是单线程，所有的网络请求或者异步任务都交给了内部的线程池去实现，本身只负责不断的往返调度，由事件循环不断驱动事件执行。 

# 78.webpack怎么实现异步加载功能

答：（webpack ensure ===异步加载 	）

 解决1   

打包成同一个js非常大的话，那么我们完全可以把需要异步加载的js分类出去，利用浏览器的并发请求js文件处理，这样的话，会比加载一个js文件时间小得多。为文件配置一个新的入口就行了，这样就能打包成两个js文件，都插入html即可 

解决2

如果说这个功能是可选的。需要一种事件去触发，那么解决方案就来了，能不能在用户点击的时候，我在去所需的js。这时候我们可以写一个按钮的监听器去实现

# 79.webpack.ensure的原理 

答：就是 把一些js模块给独立出一个个js文件，然后需要用到的时候，在创建一个script对象，加入到document.head对象中即可，浏览器会自动帮我们发起请求，去请求这个js文件，在写个回调，去定义得到这个js文件后，需要做什么业务逻辑操作。 



# 80.vuex中mutations和actions的区别和用法

答：mutations**--commit触发(更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。也就是说，mutations才是改变状态的执行者。 注意：mutations只能是同步地更改状态.)

**,actions --dispatch触发**(action 类似于 mutation, 不同在于：action 提交的是 mutation,而不是直接变更状态action可以包含任意异步操作 vue 中 ajax 请求代码应该写在组件的 methods 中还是 vuex 的 action 中。 )





